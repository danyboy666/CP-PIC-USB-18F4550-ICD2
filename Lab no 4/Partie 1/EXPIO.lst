CCS PCH C Compiler, Version 4.104, 5967               13-mars-12 23:01

               Filename: E:\Electro\Programmation\Programmations_PIC_C\243-444-RK\Lab no 4\Partie 1\EXPIO.lst

               ROM used: 638 bytes (2%)
                         Largest free fragment is 32130
               RAM used: 8 (0%) at main() level
                         13 (1%) worst case
               Stack:    2 locations

*
0000:  GOTO   01C6
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... //                 Applications des microcontrolleurs               243-444-RK // 
.................... //                         Laboratoire no. 4                                   // 
.................... // Programme no 1: Expérimentation avec registre à décalage                    // 
.................... //                                                                             // 
.................... //                                                                             // 
.................... // Ce programme décode la touche appuyé et affiche quelle touche à été         // 
.................... // appuyé  en lisant les valeurs décalés en provenance de la fonction          // 
.................... // read_expanded_inputs(). Cette valeur est retransmise par la fonction        // 
.................... // write_expanded_outputs() et la DEL correspondant à la touche s'allume.      // 
.................... //                                                                             // 
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                             // 
.................... // Copyright@Dany Ferron 2012                                                  // 
.................... //                                                                             // 
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                             // 
.................... //                                                                             // 
.................... //              _________________                                              // 
.................... //            -|1              40|-RB8                                         // 
.................... //            -|                 |-RB7                                         // 
.................... //            -|    PIC18F4550   |-RB6                                         // 
.................... //            -|      @20MHz     |-RB5   /Q7 (9)                               // 
.................... //            -|                 |-RB4    CP (2)                               // 
.................... //            -|                 |-RB3   /PL (1)                               // 
.................... //            -|                 |-RB2 <- SER (14)                             // 
.................... //            -|                 |-RB1 -> SRCLK (11)                           // 
.................... //            -|                 |-RB0 -> RCLK (12)                            // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-RC7/RX <- This is the connection to the     // 
.................... //            -|                 |-RC6/TX -> MELabs serial LCD controller      // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //         RD0-|                 |-                                            // 
.................... //         RD1-|20             21|-RD2                                         // 
.................... //              -----------------                                              // 
.................... //                                                                             // 
.................... //    => Pour le point boni j'ai changé le port pour RD0 à RD2 pour la         //  
.................... //       connexion du CI 74595.                                                // 
.................... //                                                                             // 
.................... //                Configuration des connections sur les CI.                    // 
.................... //                 74165 pin    Protoboard                                     // 
.................... //                    10           +5V                                         // 
.................... //                    11           Button 1                                    // 
.................... //                    12           Button 2                                    // 
.................... //                    13           Button 3                                    // 
.................... //                    14           Button 4                                    // 
.................... //                    15           gnd                                         // 
.................... //                    3            Button 5                                    // 
.................... //                    4            Button 6                                    // 
.................... //                    5            Button 7                                    // 
.................... //                    6            Button 8                                    // 
.................... //                    8            gnd                                         // 
.................... //                    16           +5V                                         // 
.................... //                    9            pin B5                                      // 
.................... //                    1            pin B3                                      // 
.................... //                    2            pin B4                                      // 
.................... //                                                                             // 
.................... //                 74595 pin    Protoboard                                     // 
.................... //                    15           LED 1                                       // 
.................... //                    1            LED 2                                       // 
.................... //                    2            LED 3                                       // 
.................... //                    3            LED 4                                       // 
.................... //                    4            LED 5                                       // 
.................... //                    5            LED 6                                       // 
.................... //                    6            LED 7                                       // 
.................... //                    7            LED 8                                       // 
.................... //                    8            gnd                                         // 
.................... //                    13           gnd                                         // 
.................... //                    16           +5V                                         // 
.................... //                    10           +5V                                         // 
.................... //                    14           pin B2                                      // 
.................... //                    11           pin B1                                      // 
.................... //                    12           pin B0                                      // 
.................... ///////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "EXPIO.h" 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... //#FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL12                    //Divide By 12(48MHz oscillator input) 
.................... #FUSES CPUDIV4                  //System Clock by 4 
.................... #FUSES USBDIV                   //USB clock source comes from PLL divide by 2 
.................... #FUSES VREGEN                   //USB voltage regulator enabled 
.................... #FUSES ICPRT                    //ICPRT enabled 
....................  
.................... #use delay(clock=20000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................  
.................... #include "SLCD.c" 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //                             SLCD.c                                         // 
.................... //               Simplifies the use of a Serial LCD.                          // 
.................... //                                                                            // 
.................... //                                                                            // 
.................... //                                                                            // 
.................... // The value in decimal are:                                                  // 
.................... // Line 1 = 0-19                                                              // 
.................... // Line 2 = 64-83                                                             // 
.................... // Line 3 = 20-39                                                             // 
.................... // Line 4 = 84-103                                                            // 
.................... //                                                                            // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                            // 
.................... // Copyright@ Dany Ferron 2012 & Mike Coombes 2007                            // 
.................... //                                                                            // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //Values in HEXADECIMAL for LCD Display fonctions. 
.................... /* 
.................... #define clear_lcd             0x01 // Clear Display 
.................... #define return_home           0x02 // Cursor to Home position 
.................... #define entry_mode            0x06 // Normal entry mode 
.................... #define entry_mode_rev        0x04 // Normal entry mode  -reverse direction 
.................... #define entry_mode_scroll     0x07 // - with shift 
.................... #define entry_mode_scroll_rev 0x05 // reverse direction 
....................   
.................... #define system_set_8_bit      0x38 // 8 bit data mode 2 line ( 5x7 font ) 
.................... #define system_set_4_bit      0x28 // 4 bit data mode 2 line ( 5x7 font ) 
.................... #define system_set_reset      0x30 // Reset code 
.................... #define display_on            0x0C // Display ON - 2 line mode 
.................... #define display_off           0x08 // Display off 
.................... #define set_dd_line1          0x80 // Line 1 position 1 
.................... #define set_dd_line2          0xC0 // Line 2 position 1 
.................... #define set_dd_ram            0x80 // Line 1 position 1 
.................... #define write_data            0x00 // With RS = 1 
.................... #define cursor_on             0x0E // Switch Cursor ON 
.................... #define cursor_off            0x0C // Switch Cursor OFF 
.................... #define cursor_blink_on       0x0F // Cursor plus blink 
.................... #define cursor_shift_right    0x14 // Move cursor right 
.................... #define cursor_shift_left     0x10 // Move cursor left 
.................... #define display_shift_right   0x1C // Scroll display right 
.................... #define display_shift_left    0x18 // Scroll display left 
.................... */ 
....................  
....................  
.................... #include <stdio.h>       // library containing serial communication functions 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... void LCD_ClearDisplay(void) 
.................... { 
....................   printf("%c%c",0xFE,0x01); 
*
0016:  MOVLW  FE
0018:  BTFSS  F9E.4
001A:  BRA    0018
001C:  MOVWF  FAD
001E:  MOVLW  01
0020:  BTFSS  F9E.4
0022:  BRA    0020
0024:  MOVWF  FAD
.................... } 
0026:  GOTO   01F2 (RETURN)
....................            
.................... void LCD_CursorOn(void) 
.................... { 
....................   printf("%c%c",0xFE,0x0E); 
.................... } 
....................  
.................... void LCD_CursorOff(void) 
.................... { 
....................   printf("%c%c",0xFE,0x0C); 
.................... } 
....................  
.................... void LCD_DisplayOn(void) 
.................... { 
....................   printf("%c%c",0xFE,0x0C); 
.................... } 
....................  
.................... void LCD_DisplayOff(void) 
.................... { 
....................   printf("%c%c",0xFE,0x08); 
.................... } 
....................  
.................... void LCD_BlinkOn(void) 
.................... { 
....................   printf("%c%c",0xFE,0x0D); 
.................... } 
....................  
.................... void LCD_BlinkOff(void) 
.................... { 
....................   printf("%c%c",0xFE,0x0C); 
.................... } 
....................  
.................... void LCD_UnderlineOn(void) 
.................... { 
....................   printf("%c%c",0xFE,0x0E); 
.................... } 
....................  
.................... void LCD_UnderlineOff(void) 
.................... { 
....................   printf("%c%c",0xFE,0x0C); 
.................... } 
....................  
.................... void LCD_MoveRight(void) 
.................... { 
....................   printf("%c%c",0xFE,0x14); 
.................... } 
....................  
.................... void LCD_MoveLeft(void) 
.................... { 
....................   printf("%c%c",0xFE,0x10); 
.................... } 
....................  
.................... void LCD_ScrollRight(void) 
.................... { 
....................   printf("%c%c",0xFE,0x1C); 
.................... } 
....................  
.................... void LCD_ScrollLeft(void) 
.................... { 
....................   printf("%c%c",0xFE,0x18); 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                           // 
.................... // You must uncomment for your specific LCD                                  // 
.................... //                                                                           // 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... // This is for a 2x20 LCD 
.................... void LCD_Position(unsigned char line, unsigned char column) 
.................... { 
.................... unsigned char i; 
....................  
.................... if (line == 1) 
....................    i = 64; 
.................... else 
....................    i = 0;  //default is top line 
....................   
.................... if (column >= 0 && column <= 19)  
....................    i += column;  
.................... else 
....................    i = 0;  // default is column 0  
....................   
.................... printf("%c%c",0xFE,128 + i); 
....................  
.................... } 
.................... */ 
....................  
.................... // This is for a 4x20 LCD 
.................... void LCD_Position(unsigned char line, unsigned char column) 
.................... { 
.................... unsigned char i; 
....................  
.................... if (line == 1) 
*
006A:  DECFSZ 08,W
006C:  BRA    0072
....................    i = 0; 
006E:  CLRF   0A
.................... else if (line == 2) 
0070:  BRA    0094
0072:  MOVF   08,W
0074:  SUBLW  02
0076:  BNZ   007E
....................    i = 64;   
0078:  MOVLW  40
007A:  MOVWF  0A
.................... else if (line == 3) 
007C:  BRA    0094
007E:  MOVF   08,W
0080:  SUBLW  03
0082:  BNZ   008A
....................    i = 20; 
0084:  MOVLW  14
0086:  MOVWF  0A
.................... else if (line == 4) 
0088:  BRA    0094
008A:  MOVF   08,W
008C:  SUBLW  04
008E:  BNZ   0094
....................    i = 84; 
0090:  MOVLW  54
0092:  MOVWF  0A
....................   
.................... if (column >= 0 && column <= 19)  
0094:  MOVF   09,W
0096:  SUBLW  13
0098:  BNC   00A0
....................    i += column;  
009A:  MOVF   09,W
009C:  ADDWF  0A,F
.................... else 
009E:  BRA    00A2
....................    i = 0;  // default is column 0  
00A0:  CLRF   0A
....................   
.................... printf("%c%c",0xFE,128 + i); 
00A2:  MOVLW  80
00A4:  ADDWF  0A,W
00A6:  MOVWF  0B
00A8:  MOVLW  FE
00AA:  BTFSS  F9E.4
00AC:  BRA    00AA
00AE:  MOVWF  FAD
00B0:  MOVF   0B,W
00B2:  BTFSS  F9E.4
00B4:  BRA    00B2
00B6:  MOVWF  FAD
....................  
.................... } 
00B8:  GOTO   025A (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... #include "74595.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 74595 Expanded Output Chip                        //// 
.................... ////                                                                   //// 
.................... ////   Any number of these chips may be connected in serise to get     //// 
.................... ////   8 additional outputs per chip.  The cost is 3 I/O pins for      //// 
.................... ////   any number of chips.                                            //// 
.................... ////                                                                   //// 
.................... ////   write_expanded_outputs(eo);  Writes the array eo to the chips   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF EXP_OUT_ENABLE 
....................  
.................... #define EXP_OUT_ENABLE  PIN_B0 
.................... #define EXP_OUT_CLOCK   PIN_B1 
.................... #define EXP_OUT_DO      PIN_B2 
.................... #define NUMBER_OF_74595 1 
....................  
.................... #ENDIF 
....................  
....................  
.................... void write_expanded_outputs(BYTE* eo) { 
....................   BYTE i; 
....................  
....................   output_low(EXP_OUT_CLOCK); 
*
0174:  BCF    F93.1
0176:  BCF    F8A.1
....................   output_low(EXP_OUT_ENABLE); 
0178:  BCF    F93.0
017A:  BCF    F8A.0
....................  
....................   for(i=1;i<=NUMBER_OF_74595*8;++i) {  // Clock out bits from the eo array 
017C:  MOVLW  01
017E:  MOVWF  0A
0180:  MOVF   0A,W
0182:  SUBLW  08
0184:  BNC   01BA
....................     if((*(eo+(NUMBER_OF_74595-1))&0x80)==0) 
0186:  MOVFF  09,03
018A:  MOVFF  08,FE9
018E:  MOVFF  09,FEA
0192:  MOVF   FEF,W
0194:  ANDLW  80
0196:  BNZ   019E
....................       output_low(EXP_OUT_DO); 
0198:  BCF    F93.2
019A:  BCF    F8A.2
....................     else 
019C:  BRA    01A2
....................       output_high(EXP_OUT_DO); 
019E:  BCF    F93.2
01A0:  BSF    F8A.2
....................    shift_left(eo,NUMBER_OF_74595,0); 
01A2:  MOVFF  09,FEA
01A6:  MOVFF  08,FE9
01AA:  BCF    FD8.0
01AC:  RLCF   FEF,F
....................    output_high(EXP_OUT_CLOCK); 
01AE:  BCF    F93.1
01B0:  BSF    F8A.1
....................    output_low(EXP_OUT_CLOCK); 
01B2:  BCF    F93.1
01B4:  BCF    F8A.1
....................   } 
01B6:  INCF   0A,F
01B8:  BRA    0180
....................   output_high(EXP_OUT_ENABLE); 
01BA:  BCF    F93.0
01BC:  BSF    F8A.0
....................   output_low(EXP_OUT_ENABLE); 
01BE:  BCF    F93.0
01C0:  BCF    F8A.0
....................  
.................... } 
01C2:  GOTO   027A (RETURN)
....................  
.................... #include "74165.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 74165 Expanded Input Chip                         //// 
.................... ////                                                                   //// 
.................... ////   Any number of these chips may be connected in series to get     //// 
.................... ////   8 additional inputs per chip.  The cost is 3 I/O pins for       //// 
.................... ////   any number of chips.                                            //// 
.................... ////                                                                   //// 
.................... ////    read_expanded_inputs(ei);  Reads the array ei from the chips   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF EXP_IN_ENABLE 
....................  
.................... #define EXP_IN_ENABLE   PIN_B3 
.................... #define EXP_IN_CLOCK    PIN_B4 
.................... #define EXP_IN_DI       PIN_B5 
.................... #define NUMBER_OF_74165 1 
....................  
.................... #ENDIF 
....................  
....................  
.................... void read_expanded_inputs(BYTE *ei) { 
....................   BYTE i; 
....................  
....................   output_high(EXP_IN_CLOCK); 
*
002A:  BCF    F93.4
002C:  BSF    F8A.4
....................   output_low(EXP_IN_ENABLE);      // Latch all inputs 
002E:  BCF    F93.3
0030:  BCF    F8A.3
....................   output_high(EXP_IN_ENABLE); 
0032:  BCF    F93.3
0034:  BSF    F8A.3
....................  
....................   for(i=1;i<=NUMBER_OF_74165*8;++i) {      // Clock in bits to the ei structure 
0036:  MOVLW  01
0038:  MOVWF  0A
003A:  MOVF   0A,W
003C:  SUBLW  08
003E:  BNC   0062
....................     shift_left(ei,NUMBER_OF_74165,input(EXP_IN_DI)); 
0040:  BSF    F93.5
0042:  BTFSC  F81.5
0044:  BRA    004A
0046:  BCF    FD8.0
0048:  BRA    004C
004A:  BSF    FD8.0
004C:  MOVFF  09,FEA
0050:  MOVFF  08,FE9
0054:  RLCF   FEF,F
....................     output_low(EXP_IN_CLOCK); 
0056:  BCF    F93.4
0058:  BCF    F8A.4
....................     output_high(EXP_IN_CLOCK); 
005A:  BCF    F93.4
005C:  BSF    F8A.4
....................   } 
005E:  INCF   0A,F
0060:  BRA    003A
....................   output_low(EXP_IN_ENABLE); 
0062:  BCF    F93.3
0064:  BCF    F8A.3
.................... } 
0066:  GOTO   01FA (RETURN)
....................  
....................  
....................   
.................... #define DATA_IN 255 // Valeur de départ pour la variable data 
....................  
.................... void main()  
.................... { 
*
01C6:  CLRF   FF8
01C8:  BCF    FD0.7
01CA:  CLRF   FEA
01CC:  CLRF   FE9
01CE:  BSF    FB8.3
01D0:  MOVLW  08
01D2:  MOVWF  FAF
01D4:  MOVLW  02
01D6:  MOVWF  FB0
01D8:  MOVLW  A6
01DA:  MOVWF  FAC
01DC:  MOVLW  90
01DE:  MOVWF  FAB
01E0:  MOVF   FC1,W
01E2:  ANDLW  C0
01E4:  IORLW  0F
01E6:  MOVWF  FC1
01E8:  MOVLW  07
01EA:  MOVWF  FB4
01EC:  CLRF   04
01EE:  CLRF   05
....................    BYTE data; 
....................    int8 pinValue; 
....................     
....................    LCD_ClearDisplay(); 
01F0:  BRA    0016
....................     
....................    do  
....................    { 
....................       read_expanded_inputs (&data); // Lecture de la valeur du port en entré. 
01F2:  CLRF   09
01F4:  MOVLW  06
01F6:  MOVWF  08
01F8:  BRA    002A
....................       // Switch/Case pour évaluer quelle touche à été appuyé. 
....................       switch(data) 
....................       {        
01FA:  MOVF   06,W
01FC:  XORLW  FE
01FE:  BZ    021E
0200:  XORLW  03
0202:  BZ    0224
0204:  XORLW  06
0206:  BZ    022A
0208:  XORLW  0C
020A:  BZ    0230
020C:  XORLW  18
020E:  BZ    0236
0210:  XORLW  30
0212:  BZ    023C
0214:  XORLW  60
0216:  BZ    0242
0218:  XORLW  C0
021A:  BZ    0248
021C:  BRA    024E
....................        case DATA_IN-1:pinValue=1;break; 
021E:  MOVLW  01
0220:  MOVWF  07
0222:  BRA    0250
....................        case DATA_IN-2:pinValue=2;break; 
0224:  MOVLW  02
0226:  MOVWF  07
0228:  BRA    0250
....................        case DATA_IN-4:pinValue=3;break; 
022A:  MOVLW  03
022C:  MOVWF  07
022E:  BRA    0250
....................        case DATA_IN-8:pinValue=4;break; 
0230:  MOVLW  04
0232:  MOVWF  07
0234:  BRA    0250
....................        case DATA_IN-16:pinValue=5;break; 
0236:  MOVLW  05
0238:  MOVWF  07
023A:  BRA    0250
....................        case DATA_IN-32:pinValue=6;break; 
023C:  MOVLW  06
023E:  MOVWF  07
0240:  BRA    0250
....................        case DATA_IN-64:pinValue=7;break; 
0242:  MOVLW  07
0244:  MOVWF  07
0246:  BRA    0250
....................        case DATA_IN-128:pinValue=8;break; 
0248:  MOVLW  08
024A:  MOVWF  07
024C:  BRA    0250
....................        default: pinValue=0; // Valeur de la touche en relachant  
024E:  CLRF   07
....................       } 
....................          LCD_Position(1,2); 
0250:  MOVLW  01
0252:  MOVWF  08
0254:  MOVLW  02
0256:  MOVWF  09
0258:  BRA    006A
....................          printf("Touche pesee :%u",pinValue); 
025A:  MOVLW  04
025C:  MOVWF  FF6
025E:  MOVLW  00
0260:  MOVWF  FF7
0262:  MOVLW  0E
0264:  MOVWF  08
0266:  BRA    00BC
0268:  MOVFF  07,08
026C:  MOVLW  1B
026E:  MOVWF  09
0270:  BRA    0106
....................              
....................       write_expanded_outputs (&data); // Écriture de la valeur du port en sortie. 
0272:  CLRF   09
0274:  MOVLW  06
0276:  MOVWF  08
0278:  BRA    0174
....................    } while (TRUE); 
.................... } 
027A:  BRA    01F2
....................  
027C:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   IESO FCMEN HS PLL12 CPUDIV4 USBDIV
   Word  2: 0E3F   BROWNOUT WDT128 NOWDT BORV20 NOPUT VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 00A1   STVREN NODEBUG NOLVP NOXINST ICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
