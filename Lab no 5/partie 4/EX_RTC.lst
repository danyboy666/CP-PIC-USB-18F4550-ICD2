CCS PCH C Compiler, Version 4.104, 5967               21-mars-12 02:34

               Filename: F:\Electro\Programmation\Programmations_PIC_C\243-444-RK\Lab no 5\partie 4\EX_RTC.lst

               ROM used: 2286 bytes (7%)
                         Largest free fragment is 30482
               RAM used: 25 (1%) at main() level
                         37 (2%) worst case
               Stack:    3 locations

*
0000:  GOTO   0748
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... //                 Applications des microcontrolleurs               243-444-RK // 
.................... //                         Laboratoire no. 5 (partie 3)                        // 
.................... //         Programme no 1: Expérimentation avec le protocole I²C               // 
.................... //                 Modules utilisé:  ET-MINI PCF8583                           //  
.................... //                                                                             // 
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                             // 
.................... // (c) Copyright 2012 PCM Programmer                                           // 
.................... //     Tested and re-written by: Dany Ferron                                   // 
.................... //                                                                             // 
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                             // 
.................... //                                                                             // 
.................... //              _________________                                              // 
.................... //            -|1              40|-RB7                                         // 
.................... //            -|                 |-RB6                                         // 
.................... //            -|    PIC18F4550   |-RB5                                         // 
.................... //            -|      @20MHz     |-RB4                                         // 
.................... //            -|                 |-RB3                                         // 
.................... //            -|                 |-RB2                                         // 
.................... //            -|                 |-RB1 <-> SLC (serial clock)                  // 
.................... //            -|                 |-RB0 <-> SDA (serial data)                   // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-RC7/RX <- This is the connection to the     // 
.................... //            -|                 |-RC6/TX -> MELabs serial LCD controller      // 
.................... //            -|                 |-                                            // 
.................... //            -|                 |-                                            // 
.................... //         RD0-|                 |-                                            // 
.................... //         RD1-|20             21|-RD2                                         // 
.................... //              -----------------                                              // 
.................... //                                                                             // 
.................... ///////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <EX_RTC.h> 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL12                    //Divide By 12(48MHz oscillator input) 
.................... #FUSES CPUDIV4                  //System Clock by 4 
.................... #FUSES USBDIV                   //USB clock source comes from PLL divide by 2 
.................... #FUSES VREGEN                   //USB voltage regulator enabled 
.................... #FUSES ICPRT                    //ICPRT enabled 
....................  
.................... #use delay(clock=20000000) 
*
036C:  CLRF   FEA
036E:  MOVLW  18
0370:  MOVWF  FE9
0372:  MOVF   FEF,W
0374:  BZ    0390
0376:  MOVLW  06
0378:  MOVWF  01
037A:  CLRF   00
037C:  DECFSZ 00,F
037E:  BRA    037C
0380:  DECFSZ 01,F
0382:  BRA    037A
0384:  MOVLW  7B
0386:  MOVWF  00
0388:  DECFSZ 00,F
038A:  BRA    0388
038C:  DECFSZ FEF,F
038E:  BRA    0376
0390:  GOTO   081E (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................  
.................... #include <PCF8583.c> 
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                            DSPCF8583.C                                   ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// PCF8583_init() - Enable oscillator without clearing the seconds register ///  
.................... ///                 used when PIC loses power and PCF8583 run from 3V BAT    ///  
.................... ///                  (Must be called at the start of the program)            /// 
.................... /// PCF8583_set_datetime() - Writes adress and data to the PCF8583           /// 
.................... /// PCF8583_read_datetime  - Reads the data from adress location             /// 
.................... ///                                                                          /// 
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                                                                          /// 
.................... /// (c) Copyright 2012 PCM Programmer                                        /// 
.................... ///     Tested and modified by: Dany Ferron 2012                             /// 
.................... ///                             O. Dartois                                   /// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef PCF8583_SDA 
.................... #define PCF8583_SDA PIN_B0 
.................... #define PCF8583_SCL PIN_B1 
.................... #endif 
.................... #use i2c(master, sda=PCF8583_SDA, scl=PCF8583_SCL) 
*
00F6:  MOVLW  08
00F8:  MOVWF  01
00FA:  MOVLW  05
00FC:  MOVWF  00
00FE:  DECFSZ 00,F
0100:  BRA    00FE
0102:  BCF    F8A.1
0104:  BCF    F93.1
0106:  MOVLW  06
0108:  MOVWF  00
010A:  DECFSZ 00,F
010C:  BRA    010A
010E:  RLCF   22,F
0110:  BCF    F8A.0
0112:  BTFSC  FD8.0
0114:  BSF    F93.0
0116:  BTFSS  FD8.0
0118:  BCF    F93.0
011A:  BSF    F93.1
011C:  BTFSS  F81.1
011E:  BRA    011C
0120:  DECFSZ 01,F
0122:  BRA    00FA
0124:  MOVLW  05
0126:  MOVWF  00
0128:  DECFSZ 00,F
012A:  BRA    0128
012C:  BCF    F8A.1
012E:  BCF    F93.1
0130:  NOP   
0132:  BSF    F93.0
0134:  MOVLW  06
0136:  MOVWF  00
0138:  DECFSZ 00,F
013A:  BRA    0138
013C:  MOVLW  06
013E:  MOVWF  00
0140:  DECFSZ 00,F
0142:  BRA    0140
0144:  BSF    F93.1
0146:  BTFSS  F81.1
0148:  BRA    0146
014A:  CLRF   01
014C:  MOVLW  06
014E:  MOVWF  00
0150:  DECFSZ 00,F
0152:  BRA    0150
0154:  BTFSC  F81.0
0156:  BSF    01.0
0158:  BCF    F8A.1
015A:  BCF    F93.1
015C:  BCF    F8A.0
015E:  BCF    F93.0
0160:  RETLW  00
*
0394:  MOVLW  08
0396:  MOVWF  23
0398:  MOVFF  00,24
039C:  BSF    F93.0
039E:  MOVLW  06
03A0:  MOVWF  00
03A2:  DECFSZ 00,F
03A4:  BRA    03A2
03A6:  BSF    F93.1
03A8:  BTFSS  F81.1
03AA:  BRA    03A8
03AC:  BTFSC  F81.0
03AE:  BSF    FD8.0
03B0:  BTFSS  F81.0
03B2:  BCF    FD8.0
03B4:  RLCF   01,F
03B6:  MOVLW  05
03B8:  MOVWF  00
03BA:  DECFSZ 00,F
03BC:  BRA    03BA
03BE:  BCF    F93.1
03C0:  BCF    F8A.1
03C2:  DECFSZ 23,F
03C4:  BRA    039C
03C6:  BSF    F93.0
03C8:  MOVLW  06
03CA:  MOVWF  00
03CC:  DECFSZ 00,F
03CE:  BRA    03CC
03D0:  BCF    F8A.0
03D2:  MOVF   24,W
03D4:  BTFSS  FD8.2
03D6:  BCF    F93.0
03D8:  NOP   
03DA:  BSF    F93.1
03DC:  BTFSS  F81.1
03DE:  BRA    03DC
03E0:  MOVLW  05
03E2:  MOVWF  00
03E4:  DECFSZ 00,F
03E6:  BRA    03E4
03E8:  BCF    F8A.1
03EA:  BCF    F93.1
03EC:  MOVLW  06
03EE:  MOVWF  00
03F0:  DECFSZ 00,F
03F2:  BRA    03F0
03F4:  BCF    F8A.0
03F6:  BCF    F93.0
03F8:  RETLW  00
.................... #ifndef PCF8583_WRITE_ADDRESS 
.................... //#define PCF8583_WRITE_ADDRESS 0xA0 
.................... #define PCF8583_WRITE_ADDRESS 0xA2 
.................... //#define PCF8583_READ_ADDRESS 0xA1 
.................... #define PCF8583_READ_ADDRESS 0xA3 
.................... #endif 
.................... // Register addresses 
.................... #define PCF8583_CTRL_STATUS_REG 0x00 
.................... #define PCF8583_100S_REG 0x01 
.................... #define PCF8583_SECONDS_REG 0x02 
.................... #define PCF8583_MINUTES_REG 0x03 
.................... #define PCF8583_HOURS_REG 0x04 
.................... #define PCF8583_DATE_REG 0x05 
.................... #define PCF8583_MONTHS_REG 0x06 
.................... #define PCF8583_TIMER_REG 0x07 
.................... #define PCF8583_ALARM_CONTROL_REG 0x08 
.................... #define PCF8583_ALARM_100S_REG 0x09 
.................... #define PCF8583_ALARM_SECS_REG 0x0A 
.................... #define PCF8583_ALARM_MINS_REG 0x0B 
.................... #define PCF8583_ALARM_HOURS_REG 0x0C 
.................... #define PCF8583_ALARM_DATE_REG 0x0D 
.................... #define PCF8583_ALARM_MONTHS_REG 0x0E 
.................... #define PCF8583_ALARM_TIMER_REG 0x0F 
.................... // Use the first NVRAM address for the year byte. 
.................... #define PCF8583_YEAR_REG 0x10 
.................... // Commands for the Control/Status register. 
.................... #define PCF8583_START_COUNTING 0x00 
.................... #define PCF8583_STOP_COUNTING 0x80 
.................... #define PCF8583_LATCH_COUNTING 0x40 //Ajout O. Dartois 
.................... char const weekday_names[7][4] = 
.................... { 
.................... {"Dim"}, 
.................... {"Lun"}, 
.................... {"Mar"}, 
.................... {"Mer"}, 
.................... {"Jeu"}, 
.................... {"Ven"}, 
.................... {"Sam"} 
.................... }; 
.................... // This structure defines the user's date and time data. 
.................... // The values are stored as unsigned integers. The user 
.................... // should declare a structure of this type in the application 
.................... // program. Then the address of the structure should be 
.................... // passed to the PCF8583 read/write functions in this 
.................... // driver, whenever you want to talk to the chip. 
.................... typedef struct 
.................... { 
.................... int8 seconds; // 0 to 59 
.................... int8 minutes; // 0 to 59 
.................... int8 hours; // 0 to 23 (24-hour time) 
.................... int8 day; // 1 to 31 
.................... int8 month; // 1 to 12 
.................... int8 year; // 00 to 99 
.................... int8 weekday; // 0 = Sunday, 1 = Monday, etc. 
.................... }date_time_t; 
.................... //---------------------------------------------- 
.................... void PCF8583_write_byte(int8 address, int8 data) 
.................... { 
.................... disable_interrupts(GLOBAL); 
*
0162:  BCF    FF2.6
0164:  BCF    FF2.7
0166:  BTFSC  FF2.7
0168:  BRA    0164
.................... i2c_start(); 
016A:  BSF    F93.0
016C:  MOVLW  05
016E:  MOVWF  00
0170:  DECFSZ 00,F
0172:  BRA    0170
0174:  BSF    F93.1
0176:  MOVLW  06
0178:  MOVWF  00
017A:  DECFSZ 00,F
017C:  BRA    017A
017E:  BCF    F8A.0
0180:  BCF    F93.0
0182:  MOVLW  05
0184:  MOVWF  00
0186:  DECFSZ 00,F
0188:  BRA    0186
018A:  BCF    F8A.1
018C:  BCF    F93.1
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
018E:  MOVLW  A2
0190:  MOVWF  22
0192:  RCALL  00F6
.................... i2c_write(address); 
0194:  MOVFF  20,22
0198:  RCALL  00F6
.................... i2c_write(data); 
019A:  MOVFF  21,22
019E:  RCALL  00F6
.................... i2c_stop(); 
01A0:  BCF    F93.0
01A2:  NOP   
01A4:  BSF    F93.1
01A6:  BTFSS  F81.1
01A8:  BRA    01A6
01AA:  MOVLW  05
01AC:  MOVWF  00
01AE:  DECFSZ 00,F
01B0:  BRA    01AE
01B2:  BRA    01B4
01B4:  NOP   
01B6:  BSF    F93.0
01B8:  MOVLW  05
01BA:  MOVWF  00
01BC:  DECFSZ 00,F
01BE:  BRA    01BC
.................... enable_interrupts(GLOBAL); 
01C0:  MOVLW  C0
01C2:  IORWF  FF2,F
.................... } 
01C4:  RETLW  00
.................... //---------------------------------------------- 
.................... int8 PCF8583_read_byte(int8 address) 
.................... { 
.................... int8 retval; 
.................... disable_interrupts(GLOBAL); 
*
0420:  BCF    FF2.6
0422:  BCF    FF2.7
0424:  BTFSC  FF2.7
0426:  BRA    0422
.................... i2c_start(); 
0428:  BSF    F93.0
042A:  MOVLW  05
042C:  MOVWF  00
042E:  DECFSZ 00,F
0430:  BRA    042E
0432:  BSF    F93.1
0434:  MOVLW  06
0436:  MOVWF  00
0438:  DECFSZ 00,F
043A:  BRA    0438
043C:  BCF    F8A.0
043E:  BCF    F93.0
0440:  MOVLW  05
0442:  MOVWF  00
0444:  DECFSZ 00,F
0446:  BRA    0444
0448:  BCF    F8A.1
044A:  BCF    F93.1
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
044C:  MOVLW  A2
044E:  MOVWF  22
0450:  RCALL  00F6
.................... i2c_write(address); 
0452:  MOVFF  20,22
0456:  RCALL  00F6
.................... i2c_start(); 
0458:  BSF    F93.0
045A:  MOVLW  05
045C:  MOVWF  00
045E:  DECFSZ 00,F
0460:  BRA    045E
0462:  BSF    F93.1
0464:  MOVLW  06
0466:  MOVWF  00
0468:  DECFSZ 00,F
046A:  BRA    0468
046C:  BTFSS  F81.1
046E:  BRA    046C
0470:  BCF    F8A.0
0472:  BCF    F93.0
0474:  MOVLW  05
0476:  MOVWF  00
0478:  DECFSZ 00,F
047A:  BRA    0478
047C:  BCF    F8A.1
047E:  BCF    F93.1
.................... i2c_write(PCF8583_READ_ADDRESS); 
0480:  MOVLW  A3
0482:  MOVWF  22
0484:  RCALL  00F6
.................... retval = i2c_read(0); 
0486:  CLRF   00
0488:  RCALL  0394
048A:  MOVFF  01,21
.................... i2c_stop(); 
048E:  BCF    F93.0
0490:  NOP   
0492:  BSF    F93.1
0494:  BTFSS  F81.1
0496:  BRA    0494
0498:  MOVLW  05
049A:  MOVWF  00
049C:  DECFSZ 00,F
049E:  BRA    049C
04A0:  BRA    04A2
04A2:  NOP   
04A4:  BSF    F93.0
04A6:  MOVLW  05
04A8:  MOVWF  00
04AA:  DECFSZ 00,F
04AC:  BRA    04AA
.................... enable_interrupts(GLOBAL); 
04AE:  MOVLW  C0
04B0:  IORWF  FF2,F
.................... return(retval); 
04B2:  MOVFF  21,01
.................... } 
04B6:  GOTO   065E (RETURN)
.................... void PCF8583_init(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
.................... PCF8583_START_COUNTING); 
*
01C6:  CLRF   20
01C8:  CLRF   21
01CA:  RCALL  0162
.................... } 
01CC:  GOTO   0770 (RETURN)
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit binary value 
.................... // to an 8 bit BCD value. 
.................... // The input range must be from 0 to 99. 
.................... int8 bin2bcd(int8 value) 
.................... { 
.................... char retval; 
.................... retval = 0; 
*
01F2:  CLRF   20
.................... while(TRUE) 
.................... { 
.................... // Get the tens digit by doing multiple subtraction 
.................... // of 10 from the binary value. 
.................... if(value >= 10) 
01F4:  MOVF   1F,W
01F6:  SUBLW  09
01F8:  BC    0204
.................... { 
.................... value -= 10; 
01FA:  MOVLW  0A
01FC:  SUBWF  1F,F
.................... retval += 0x10; 
01FE:  MOVLW  10
0200:  ADDWF  20,F
.................... } 
.................... else // Get the ones digit by adding the remainder. 
0202:  BRA    020A
.................... { 
.................... retval += value; 
0204:  MOVF   1F,W
0206:  ADDWF  20,F
.................... break; 
0208:  BRA    020C
.................... } 
.................... } 
020A:  BRA    01F4
.................... return(retval); 
020C:  MOVFF  20,01
.................... } 
0210:  RETLW  00
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit BCD value to 
.................... // an 8 bit binary value. 
.................... // The input range must be from 00 to 99. 
.................... char bcd2bin(char bcd_value) 
.................... { 
.................... char temp; 
.................... temp = bcd_value; 
*
03FA:  MOVFF  23,24
.................... // Shifting the upper digit right by 1 is 
.................... // the same as multiplying it by 8. 
.................... temp >>= 1; 
03FE:  BCF    FD8.0
0400:  RRCF   24,F
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
0402:  MOVLW  78
0404:  ANDWF  24,F
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
0406:  RRCF   24,W
0408:  MOVWF  00
040A:  RRCF   00,F
040C:  MOVLW  3F
040E:  ANDWF  00,F
0410:  MOVF   00,W
0412:  ADDWF  24,W
0414:  MOVWF  25
0416:  MOVF   23,W
0418:  ANDLW  0F
041A:  ADDWF  25,W
041C:  MOVWF  01
.................... } 
041E:  RETLW  00
.................... //---------------------------------------------- 
.................... void PCF8583_set_datetime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
*
0212:  MOVF   17,W
0214:  MOVWF  FE9
0216:  MOVFF  18,FEA
021A:  MOVFF  FEF,1E
021E:  MOVFF  1E,1F
0222:  RCALL  01F2
0224:  MOVFF  01,19
.................... bcd_min = bin2bcd(dt->minutes); 
0228:  MOVLW  01
022A:  ADDWF  17,W
022C:  MOVWF  FE9
022E:  MOVLW  00
0230:  ADDWFC 18,W
0232:  MOVWF  FEA
0234:  MOVFF  FEF,1E
0238:  MOVFF  1E,1F
023C:  RCALL  01F2
023E:  MOVFF  01,1A
.................... bcd_hrs = bin2bcd(dt->hours); 
0242:  MOVLW  02
0244:  ADDWF  17,W
0246:  MOVWF  FE9
0248:  MOVLW  00
024A:  ADDWFC 18,W
024C:  MOVWF  FEA
024E:  MOVFF  FEF,1E
0252:  MOVFF  1E,1F
0256:  RCALL  01F2
0258:  MOVFF  01,1B
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
025C:  MOVLW  03
025E:  ADDWF  17,W
0260:  MOVWF  FE9
0262:  MOVLW  00
0264:  ADDWFC 18,W
0266:  MOVWF  FEA
0268:  MOVFF  FEF,1E
026C:  MOVFF  1E,1F
0270:  RCALL  01F2
0272:  MOVLW  05
0274:  ADDWF  17,W
0276:  MOVWF  FE9
0278:  MOVLW  00
027A:  ADDWFC 18,W
027C:  MOVWF  FEA
027E:  SWAPF  FEF,W
0280:  MOVWF  00
0282:  RLCF   00,F
0284:  RLCF   00,F
0286:  MOVLW  C0
0288:  ANDWF  00,F
028A:  MOVF   00,W
028C:  IORWF  01,W
028E:  MOVWF  1C
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
0290:  MOVLW  04
0292:  ADDWF  17,W
0294:  MOVWF  FE9
0296:  MOVLW  00
0298:  ADDWFC 18,W
029A:  MOVWF  FEA
029C:  MOVFF  FEF,1E
02A0:  MOVFF  1E,1F
02A4:  RCALL  01F2
02A6:  MOVLW  06
02A8:  ADDWF  17,W
02AA:  MOVWF  FE9
02AC:  MOVLW  00
02AE:  ADDWFC 18,W
02B0:  MOVWF  FEA
02B2:  SWAPF  FEF,W
02B4:  MOVWF  00
02B6:  RLCF   00,F
02B8:  MOVLW  E0
02BA:  ANDWF  00,F
02BC:  MOVF   00,W
02BE:  IORWF  01,W
02C0:  MOVWF  1D
.................... // Stop the RTC from counting, before we write to 
.................... // the date and time registers. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
.................... PCF8583_STOP_COUNTING); 
02C2:  CLRF   20
02C4:  MOVLW  80
02C6:  MOVWF  21
02C8:  RCALL  0162
.................... // Write to the date and time registers. Disable interrupts 
.................... // so they can't disrupt the i2c operations. 
.................... disable_interrupts(GLOBAL); 
02CA:  BCF    FF2.6
02CC:  BCF    FF2.7
02CE:  BTFSC  FF2.7
02D0:  BRA    02CC
.................... i2c_start(); 
02D2:  BSF    F93.0
02D4:  MOVLW  05
02D6:  MOVWF  00
02D8:  DECFSZ 00,F
02DA:  BRA    02D8
02DC:  BSF    F93.1
02DE:  MOVLW  06
02E0:  MOVWF  00
02E2:  DECFSZ 00,F
02E4:  BRA    02E2
02E6:  BCF    F8A.0
02E8:  BCF    F93.0
02EA:  MOVLW  05
02EC:  MOVWF  00
02EE:  DECFSZ 00,F
02F0:  BRA    02EE
02F2:  BCF    F8A.1
02F4:  BCF    F93.1
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
02F6:  MOVLW  A2
02F8:  MOVWF  22
02FA:  RCALL  00F6
.................... i2c_write(PCF8583_100S_REG); // Start at 100's reg. 
02FC:  MOVLW  01
02FE:  MOVWF  22
0300:  RCALL  00F6
.................... i2c_write(0x00); // Set 100's reg = 0 
0302:  CLRF   22
0304:  RCALL  00F6
.................... i2c_write(bcd_sec); 
0306:  MOVFF  19,22
030A:  RCALL  00F6
.................... i2c_write(bcd_min); 
030C:  MOVFF  1A,22
0310:  RCALL  00F6
.................... i2c_write(bcd_hrs); 
0312:  MOVFF  1B,22
0316:  RCALL  00F6
.................... i2c_write(bcd_day); 
0318:  MOVFF  1C,22
031C:  RCALL  00F6
.................... i2c_write(bcd_mon); 
031E:  MOVFF  1D,22
0322:  RCALL  00F6
.................... i2c_stop(); 
0324:  BCF    F93.0
0326:  NOP   
0328:  BSF    F93.1
032A:  BTFSS  F81.1
032C:  BRA    032A
032E:  MOVLW  05
0330:  MOVWF  00
0332:  DECFSZ 00,F
0334:  BRA    0332
0336:  BRA    0338
0338:  NOP   
033A:  BSF    F93.0
033C:  MOVLW  05
033E:  MOVWF  00
0340:  DECFSZ 00,F
0342:  BRA    0340
.................... enable_interrupts(GLOBAL); 
0344:  MOVLW  C0
0346:  IORWF  FF2,F
.................... // Write the year byte to the first NVRAM location. 
.................... // Leave it in binary format. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year); 
0348:  MOVLW  05
034A:  ADDWF  17,W
034C:  MOVWF  FE9
034E:  MOVLW  00
0350:  ADDWFC 18,W
0352:  MOVWF  FEA
0354:  MOVFF  FEF,1E
0358:  MOVLW  10
035A:  MOVWF  20
035C:  MOVFF  1E,21
0360:  RCALL  0162
.................... // Now allow the PCF8583 to start counting again. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
.................... PCF8583_START_COUNTING); 
0362:  CLRF   20
0364:  CLRF   21
0366:  RCALL  0162
.................... } 
0368:  GOTO   07CA (RETURN)
.................... //---------------------------------------------- 
.................... // Read the Date and Time from the hardware registers 
.................... // in the PCF8583. We don't have to disable counting 
.................... // during read operations, because according to the data 
.................... // sheet, if any of the lower registers (1 to 7) is read, 
.................... // all of them are loaded into "capture" registers. 
.................... // All further reading within that cycle is done from 
.................... // those registers. 
.................... void PCF8583_read_datetime(date_time_t *dt) 
.................... { 
.................... int8 year_bits; 
.................... int8 year; 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
.................... // Disable interrupts so the i2c process is not disrupted. 
.................... disable_interrupts(GLOBAL); 
*
04BA:  BCF    FF2.6
04BC:  BCF    FF2.7
04BE:  BTFSC  FF2.7
04C0:  BRA    04BC
.................... // Read the date/time registers inside the PCF8583. 
.................... i2c_start(); 
04C2:  BSF    F93.0
04C4:  MOVLW  05
04C6:  MOVWF  00
04C8:  DECFSZ 00,F
04CA:  BRA    04C8
04CC:  BSF    F93.1
04CE:  MOVLW  06
04D0:  MOVWF  00
04D2:  DECFSZ 00,F
04D4:  BRA    04D2
04D6:  BCF    F8A.0
04D8:  BCF    F93.0
04DA:  MOVLW  05
04DC:  MOVWF  00
04DE:  DECFSZ 00,F
04E0:  BRA    04DE
04E2:  BCF    F8A.1
04E4:  BCF    F93.1
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
04E6:  MOVLW  A2
04E8:  MOVWF  22
04EA:  RCALL  00F6
.................... i2c_write(PCF8583_SECONDS_REG); // Start at seconds reg. 
04EC:  MOVLW  02
04EE:  MOVWF  22
04F0:  RCALL  00F6
.................... i2c_start(); 
04F2:  BSF    F93.0
04F4:  MOVLW  05
04F6:  MOVWF  00
04F8:  DECFSZ 00,F
04FA:  BRA    04F8
04FC:  BSF    F93.1
04FE:  MOVLW  06
0500:  MOVWF  00
0502:  DECFSZ 00,F
0504:  BRA    0502
0506:  BTFSS  F81.1
0508:  BRA    0506
050A:  BCF    F8A.0
050C:  BCF    F93.0
050E:  MOVLW  05
0510:  MOVWF  00
0512:  DECFSZ 00,F
0514:  BRA    0512
0516:  BCF    F8A.1
0518:  BCF    F93.1
.................... i2c_write(PCF8583_READ_ADDRESS); 
051A:  MOVLW  A3
051C:  MOVWF  22
051E:  RCALL  00F6
.................... bcd_sec = i2c_read(); 
0520:  MOVLW  01
0522:  MOVWF  00
0524:  RCALL  0394
0526:  MOVFF  01,1B
.................... bcd_min = i2c_read(); 
052A:  MOVLW  01
052C:  MOVWF  00
052E:  RCALL  0394
0530:  MOVFF  01,1C
.................... bcd_hrs = i2c_read(); 
0534:  MOVLW  01
0536:  MOVWF  00
0538:  RCALL  0394
053A:  MOVFF  01,1D
.................... bcd_day = i2c_read(); 
053E:  MOVLW  01
0540:  MOVWF  00
0542:  RCALL  0394
0544:  MOVFF  01,1E
.................... bcd_mon = i2c_read(0); 
0548:  CLRF   00
054A:  RCALL  0394
054C:  MOVFF  01,1F
.................... i2c_stop(); 
0550:  BCF    F93.0
0552:  NOP   
0554:  BSF    F93.1
0556:  BTFSS  F81.1
0558:  BRA    0556
055A:  MOVLW  05
055C:  MOVWF  00
055E:  DECFSZ 00,F
0560:  BRA    055E
0562:  BRA    0564
0564:  NOP   
0566:  BSF    F93.0
0568:  MOVLW  05
056A:  MOVWF  00
056C:  DECFSZ 00,F
056E:  BRA    056C
.................... enable_interrupts(GLOBAL); 
0570:  MOVLW  C0
0572:  IORWF  FF2,F
.................... // Convert the date/time values from BCD to 
.................... // unsigned 8-bit integers. Unpack the bits 
.................... // in the PCF8583 registers where required. 
.................... dt->seconds = bcd2bin(bcd_sec); 
0574:  MOVFF  17,01
0578:  MOVFF  18,03
057C:  MOVFF  17,20
0580:  MOVFF  18,21
0584:  MOVFF  1B,23
0588:  RCALL  03FA
058A:  MOVFF  21,FEA
058E:  MOVFF  20,FE9
0592:  MOVFF  01,FEF
.................... dt->minutes = bcd2bin(bcd_min); 
0596:  MOVLW  01
0598:  ADDWF  17,W
059A:  MOVWF  01
059C:  MOVLW  00
059E:  ADDWFC 18,W
05A0:  MOVWF  03
05A2:  MOVFF  01,20
05A6:  MOVWF  21
05A8:  MOVFF  1C,23
05AC:  RCALL  03FA
05AE:  MOVFF  21,FEA
05B2:  MOVFF  20,FE9
05B6:  MOVFF  01,FEF
.................... dt->hours = bcd2bin(bcd_hrs & 0x3F); 
05BA:  MOVLW  02
05BC:  ADDWF  17,W
05BE:  MOVWF  01
05C0:  MOVLW  00
05C2:  ADDWFC 18,W
05C4:  MOVWF  03
05C6:  MOVFF  01,20
05CA:  MOVWF  21
05CC:  MOVF   1D,W
05CE:  ANDLW  3F
05D0:  MOVWF  22
05D2:  MOVWF  23
05D4:  RCALL  03FA
05D6:  MOVFF  21,FEA
05DA:  MOVFF  20,FE9
05DE:  MOVFF  01,FEF
.................... dt->day = bcd2bin(bcd_day & 0x3F); 
05E2:  MOVLW  03
05E4:  ADDWF  17,W
05E6:  MOVWF  01
05E8:  MOVLW  00
05EA:  ADDWFC 18,W
05EC:  MOVWF  03
05EE:  MOVFF  01,20
05F2:  MOVWF  21
05F4:  MOVF   1E,W
05F6:  ANDLW  3F
05F8:  MOVWF  22
05FA:  MOVWF  23
05FC:  RCALL  03FA
05FE:  MOVFF  21,FEA
0602:  MOVFF  20,FE9
0606:  MOVFF  01,FEF
.................... dt->month = bcd2bin(bcd_mon & 0x1F); 
060A:  MOVLW  04
060C:  ADDWF  17,W
060E:  MOVWF  01
0610:  MOVLW  00
0612:  ADDWFC 18,W
0614:  MOVWF  03
0616:  MOVFF  01,20
061A:  MOVWF  21
061C:  MOVF   1F,W
061E:  ANDLW  1F
0620:  MOVWF  22
0622:  MOVWF  23
0624:  RCALL  03FA
0626:  MOVFF  21,FEA
062A:  MOVFF  20,FE9
062E:  MOVFF  01,FEF
.................... dt->weekday = bcd_mon >> 5; 
0632:  MOVLW  06
0634:  ADDWF  17,W
0636:  MOVWF  FE9
0638:  MOVLW  00
063A:  ADDWFC 18,W
063C:  MOVWF  FEA
063E:  SWAPF  1F,W
0640:  MOVWF  00
0642:  RRCF   00,F
0644:  MOVLW  07
0646:  ANDWF  00,F
0648:  MOVFF  00,FEF
.................... year_bits = bcd_day >> 6; 
064C:  SWAPF  1E,W
064E:  MOVWF  19
0650:  RRCF   19,F
0652:  RRCF   19,F
0654:  MOVLW  03
0656:  ANDWF  19,F
.................... // Read the year byte from NVRAM. 
.................... // This is an added feature of this driver. 
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG); 
0658:  MOVLW  10
065A:  MOVWF  20
065C:  BRA    0420
065E:  MOVFF  01,1A
.................... // Check if the two "year bits" were incremented by 
.................... // the PCF8583. If so, increment the 8-bit year 
.................... // byte (read from NVRAM) by the same amount. 
.................... while(year_bits != (year & 3)) 
.................... year++; 
0662:  MOVF   1A,W
0664:  ANDLW  03
0666:  SUBWF  19,W
0668:  BZ    066E
066A:  INCF   1A,F
066C:  BRA    0662
.................... dt->year = year; 
066E:  MOVLW  05
0670:  ADDWF  17,W
0672:  MOVWF  FE9
0674:  MOVLW  00
0676:  ADDWFC 18,W
0678:  MOVWF  FEA
067A:  MOVFF  1A,FEF
.................... // Now update the year byte in the NVRAM 
.................... // inside the PCF8583. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year); 
067E:  MOVLW  10
0680:  MOVWF  20
0682:  MOVFF  1A,21
0686:  RCALL  0162
.................... } 
0688:  GOTO   082A (RETURN)
....................  
....................  
.................... // The default date format for this test program is MM/DD/YY.  
.................... // If you want to use Euro format (DD/MM/YY), then un-comment  
.................... // the following line.  
.................... // #define USE_EURO_DATE_FORMAT  1  
....................  
.................... //=================================  
.................... void main()  
.................... {  
*
0748:  CLRF   FF8
074A:  BCF    FD0.7
074C:  CLRF   FEA
074E:  CLRF   FE9
0750:  BSF    FB8.3
0752:  MOVLW  08
0754:  MOVWF  FAF
0756:  MOVLW  02
0758:  MOVWF  FB0
075A:  MOVLW  A6
075C:  MOVWF  FAC
075E:  MOVLW  90
0760:  MOVWF  FAB
0762:  MOVF   FC1,W
0764:  ANDLW  C0
0766:  IORLW  0F
0768:  MOVWF  FC1
076A:  MOVLW  07
076C:  MOVWF  FB4
.................... char c;  
.................... char weekday[10];  
.................... date_time_t dt;  
....................  
....................  
.................... PCF8583_init();  
076E:  BRA    01C6
....................  
.................... // Allow the user to write a preset date and time to the  
.................... // PCF8583, if desired.   
.................... printf("Do you want to write a sample date/time of\n\r");  
0770:  MOVLW  30
0772:  MOVWF  FF6
0774:  MOVLW  00
0776:  MOVWF  FF7
0778:  RCALL  01D0
....................  
.................... #ifdef USE_EURO_DATE_FORMAT  
.................... printf("23/12/06 23:59:50 (Sunday) to the PCF8583 ? (Y/N)\n\r");  
.................... #else  // Use U.S. date format  
.................... printf("12/23/06 23:59:50 (Sunday) to the PCF8583 ? (Y/N)\n\r");  
077A:  MOVLW  5E
077C:  MOVWF  FF6
077E:  MOVLW  00
0780:  MOVWF  FF7
0782:  RCALL  01D0
.................... #endif  
....................  
.................... while(TRUE)  
....................   {  
....................    c = getc();    // Wait for user to press a key  
0784:  BTFSS  F9E.5
0786:  BRA    0784
0788:  MOVFF  FAE,05
....................    c = toupper(c);  
078C:  MOVF   05,W
078E:  SUBLW  60
0790:  BC    079E
0792:  MOVF   05,W
0794:  SUBLW  7A
0796:  BNC   079E
0798:  MOVF   05,W
079A:  ANDLW  DF
079C:  BRA    07A0
079E:  MOVF   05,W
07A0:  MOVWF  05
....................      
....................    if(c == 'Y')  
07A2:  MOVF   05,W
07A4:  SUBLW  59
07A6:  BNZ   07F0
....................      {  
....................       dt.month   = 12;    // December  
07A8:  MOVLW  0C
07AA:  MOVWF  14
....................       dt.day     = 31;    // 31  
07AC:  MOVLW  1F
07AE:  MOVWF  13
....................       dt.year    = 06;    // 2006  
07B0:  MOVLW  06
07B2:  MOVWF  15
....................       dt.hours   = 23;    // 23 hours (11pm in 24-hour time)  
07B4:  MOVLW  17
07B6:  MOVWF  12
....................       dt.minutes = 59;    // 59 minutes   
07B8:  MOVLW  3B
07BA:  MOVWF  11
....................       dt.seconds = 50;    // 50 seconds  
07BC:  MOVLW  32
07BE:  MOVWF  10
....................       dt.weekday = 0;     // 0 = Sunday, 1 = Monday, etc.  
07C0:  CLRF   16
....................  
....................       PCF8583_set_datetime(&dt);         
07C2:  CLRF   18
07C4:  MOVLW  10
07C6:  MOVWF  17
07C8:  BRA    0212
....................       printf("\n\r");  
07CA:  MOVLW  0A
07CC:  BTFSS  F9E.4
07CE:  BRA    07CC
07D0:  MOVWF  FAD
07D2:  MOVLW  0D
07D4:  BTFSS  F9E.4
07D6:  BRA    07D4
07D8:  MOVWF  FAD
....................       printf("New date/time written to PCF8583.\n\r");  
07DA:  MOVLW  92
07DC:  MOVWF  FF6
07DE:  MOVLW  00
07E0:  MOVWF  FF7
07E2:  RCALL  01D0
....................       printf("Watch it rollover to 2007.\n\r");  
07E4:  MOVLW  B6
07E6:  MOVWF  FF6
07E8:  MOVLW  00
07EA:  MOVWF  FF7
07EC:  RCALL  01D0
....................       break;  
07EE:  BRA    07FA
....................      }  
....................  
....................    if(c == 'N')  
07F0:  MOVF   05,W
07F2:  SUBLW  4E
07F4:  BNZ   07F8
....................       break;   
07F6:  BRA    07FA
....................   }  
07F8:  BRA    0784
....................  
.................... printf("\n\r");  
07FA:  MOVLW  0A
07FC:  BTFSS  F9E.4
07FE:  BRA    07FC
0800:  MOVWF  FAD
0802:  MOVLW  0D
0804:  BTFSS  F9E.4
0806:  BRA    0804
0808:  MOVWF  FAD
.................... printf("Reading date/time from PCF8583:\n\r");  
080A:  MOVLW  D4
080C:  MOVWF  FF6
080E:  MOVLW  00
0810:  MOVWF  FF7
0812:  RCALL  01D0
....................  
.................... // Read the date and time from the PCF8583 and display  
.................... // it once per second.  
.................... while(TRUE)  
....................   {  
....................    delay_ms(1000);     
0814:  MOVLW  04
0816:  MOVWF  17
0818:  MOVLW  FA
081A:  MOVWF  18
081C:  BRA    036C
081E:  DECFSZ 17,F
0820:  BRA    0818
....................  
....................    PCF8583_read_datetime(&dt);     
0822:  CLRF   18
0824:  MOVLW  10
0826:  MOVWF  17
0828:  BRA    04BA
....................  
....................    strcpy(weekday, weekday_names[dt.weekday]);  
082A:  MOVF   16,W
082C:  MULLW  04
082E:  MOVF   FF3,W
0830:  CLRF   03
0832:  MOVWF  17
0834:  CLRF   FEA
0836:  MOVLW  06
0838:  MOVWF  FE9
083A:  MOVFF  FF2,18
083E:  BCF    FF2.7
0840:  MOVF   17,W
0842:  CALL   0004
0846:  TBLRD*-
0848:  TBLRD*+
084A:  MOVF   FF5,W
084C:  MOVWF  FEE
084E:  IORLW  00
0850:  BNZ   0848
0852:  BTFSC  18.7
0854:  BSF    FF2.7
....................  
....................    #ifdef USE_EURO_DATE_FORMAT  
....................    printf("%s, %u/%u/%02u, %u:%02u:%02u\n\r",  
....................            weekday, dt.day, dt.month, dt.year,  
....................            dt.hours, dt.minutes, dt.seconds);  
....................    #else  // Use U.S. date format  
....................    printf("%s, %u/%u/%02u, %u:%02u:%02u\n\r",  
....................            weekday, dt.month, dt.day, dt.year,  
....................            dt.hours, dt.minutes, dt.seconds);  
0856:  CLRF   FEA
0858:  MOVLW  06
085A:  MOVWF  FE9
085C:  BRA    068C
085E:  MOVLW  2C
0860:  BTFSS  F9E.4
0862:  BRA    0860
0864:  MOVWF  FAD
0866:  MOVLW  20
0868:  BTFSS  F9E.4
086A:  BRA    0868
086C:  MOVWF  FAD
086E:  MOVFF  14,17
0872:  MOVLW  1B
0874:  MOVWF  18
0876:  RCALL  06DC
0878:  MOVLW  2F
087A:  BTFSS  F9E.4
087C:  BRA    087A
087E:  MOVWF  FAD
0880:  MOVFF  13,17
0884:  MOVLW  1B
0886:  MOVWF  18
0888:  RCALL  06DC
088A:  MOVLW  2F
088C:  BTFSS  F9E.4
088E:  BRA    088C
0890:  MOVWF  FAD
0892:  MOVFF  15,17
0896:  MOVLW  01
0898:  MOVWF  18
089A:  RCALL  06DC
089C:  MOVLW  2C
089E:  BTFSS  F9E.4
08A0:  BRA    089E
08A2:  MOVWF  FAD
08A4:  MOVLW  20
08A6:  BTFSS  F9E.4
08A8:  BRA    08A6
08AA:  MOVWF  FAD
08AC:  MOVFF  12,17
08B0:  MOVLW  1B
08B2:  MOVWF  18
08B4:  RCALL  06DC
08B6:  MOVLW  3A
08B8:  BTFSS  F9E.4
08BA:  BRA    08B8
08BC:  MOVWF  FAD
08BE:  MOVFF  11,17
08C2:  MOVLW  01
08C4:  MOVWF  18
08C6:  RCALL  06DC
08C8:  MOVLW  3A
08CA:  BTFSS  F9E.4
08CC:  BRA    08CA
08CE:  MOVWF  FAD
08D0:  MOVFF  10,17
08D4:  MOVLW  01
08D6:  MOVWF  18
08D8:  RCALL  06DC
08DA:  MOVLW  0A
08DC:  BTFSS  F9E.4
08DE:  BRA    08DC
08E0:  MOVWF  FAD
08E2:  MOVLW  0D
08E4:  BTFSS  F9E.4
08E6:  BRA    08E4
08E8:  MOVWF  FAD
....................    #endif  
....................   }  
08EA:  BRA    0814
....................  
.................... }  
....................  
08EC:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   IESO FCMEN HS PLL12 CPUDIV4 USBDIV
   Word  2: 0E3F   BROWNOUT WDT128 NOWDT BORV20 NOPUT VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 00A5   STVREN NODEBUG LVP NOXINST ICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
