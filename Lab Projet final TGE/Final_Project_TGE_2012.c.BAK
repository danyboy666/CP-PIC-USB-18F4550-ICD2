////////////////////////////////////////////////////////////////////////////////
//                 Applications des microcontrolleurs              243-444-RK //
//                                                                            //
//                             Projet Final                                   //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
//                  Decription:                                               //
//                                                                            //
// Partie : A :   Obligatoire                     pour un total de 50 %       //
// 1.   Le système est sécurisé et attend la lecture de votre code numérique  //
// d'accès (NIP). Il vous l'indique par une invitation à introduire votre code// 
// d'accès et affiche l'heure. Le code d'accès est composer de 6 chiffres     //
// moins si votre programme gère la touche retour arrière et la touche entrée,// 
// voir partie : bonus : C.                                                   //
//                                                                            //
// 2.   Suite à la lecture de celui-ci, votre programme interroge sa banque   //
// de données pour savoir si vous êtes un étudiant valide                     //
// "   Si c'est le cas, le système vous salue et emmagasine en mémoire interne// 
// interne votre nom ainsi que l'heure (en mémoire externe voir partie : B)   //
// "   Si ce n'est pas le cas le système vous informe que vous n'aurez pas    //
// accès au système et le système se réinitialise c. à d. qu'il se met en     //
// attente de lecture de votre code numérique.                                //
// "   Le système connaît minimalement 4 personnes, dont Paul avec le         //
// code : 123456                                                              //
//                                                                            //
// 3.   Si vous êtes Paul (administrateur) vous pouvez modifier l'heure du    //
// RTC et savoir les 10 dernières personnes qui sont entrées sur le système.  //
// Il peut contrôler l'affichage des noms à l'écran                           //
//                                                                            //
// 4.   Si vous êtes une personne autorisée, vous pouvez avoir accès à la     //
// partie E et F                                                              //
//                                                                            //
// 5.   Lors d'une alimentation, affichez le logo ou l'identifiant de         //
// votre compagnie                                                            //
//                                                                            //
// Partie B: au choix                        pour un total de 10 %            //
// Vous mémoriser la date et l'heure de l'accès en mémoire EEPROM extérieur   //
//                                                                            //
// Partie C: au choix                        pour un total de 10 %            //
// Rendre la lecture sensible à la touche retour arrière et la touche entrée  //
//                                                                            //
// Partie D: au choix                        pour un total de 10 %            //
// La banque de donné connaît deux personnes qui non pas de NIP               //
// 1.   Si vous n'avez pas de NIP et que vous êtes dans la banque de données! //
// Vous pouvez en choisir un en mettant une entrée à un niveau zéro, vous     //
// êtes alors en mode de configuration. Après avoir identifié votre nom son   //
// numéro correspondant, fournie dans une liste déroulante (contrôlé par      //
// l'utilisateur) le système reconnaît que vous n'avez pas de NIP :           //
// o   Le système vous salue, Il vous demande, de choisir un NIP de 6 touches //
// consécutif sur le clavier. Qu'il vous demandera de répéter une deuxième    //
// fois pour validation et si tout se passe bien le système le mémorise et    //
// vous autorise à continuer.                                                 //
// o   Si un délai supérieur à 60 secondes se passe entre la mise à un niveau //
// zéro de l'entrée et l'introduction de votre NIP une première fois. Le      //
// système se réinitialise, retour à la partie : A.1.                         //
//                                                                            //
// 2.   Si vous avez déjà un NIP vous pouvez en choisir un autre en mettant   //
// même entrée à niveau zéro, vous êtes en mode programmation. Après avoir    //
// identifié votre nom dans une liste déroulante (contrôlé par l'utilisateur) //
// avec son numéro correspondant, le système reconnaît que vous avez déjà un  //
// NIP : le système vous demande de le changer après vous avoir identifié     //
// avec l'ancien numéro.                                                      //
// o   Si tout se passe bien le système le mémorise et vous autorise à        //
// continuer.                                                                 //
// o   Si ce n'est pas le cas le système le système se réinitialise.et vous   //
// conserver votre ancien numéro.                                             //
//                                                                            //
// Partie E: au choix                        pour un total de 10 %            //
// Contrôler la vitesse d'un moteur CC à l'aide d'un potentiomètre            //
// (sur toute la page de celui-ci). Afficher la vitesse de celui-ci à         //
// l'aide d'un graphique barre                                                //
//                                                                            //
// Partie F: au choix                        pour un total de 10 %            //
// Afficher la vitesse du moteur avec le tachymètre                           //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// (c)Copyright 2012 Dany Ferron                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                                                            //
//              _________________                                             //
//            -|1              40|-RB7                                        //
//    RA0/ANA0-|                 |-RB6                                        //
//            -|    PIC18F4550   |-RB5                                        //
//            -|      @20MHz     |-RB4                                        //
//            -|                 |-RB3                                        //
//            -|                 |-RB2/INT2    <- Interrupt                   //
//            -|                 |-RB1                                        //
//            -|                 |-RB0                                        //
//            -|                 |-                                           //
//            -|                 |-                                           //
//            -|                 |-                                           //
//            -|                 |-                                           //
//            -|                 |-                                           //
//            -|                 |-                                           //
//            -|                 |-RC7/RX <- This is the connection to the    //
//            -|                 |-RC6/TX -> MELabs 4X20 serial LCD           //
//            -|                 |-          controller                       //
//            -|                 |-                                           //
//         RD0-|                 |-                                           //
//         RD1-|20             21|-RD2                                        //
//              -----------------                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////Include header file///////////////////////////////////
#include "Final_Project_TGE_2012.h"

//////////////////Include driver source used in this project////////////////////
#include "Matrix_Keypad4X4_W.INT.c"
#include "RTC_Clock.c"
#include "Serial_EXT_EEPROM.c"
#include "SLCD.c"

//#zero_ram // S'assure que le registre interne servant à tenir les variables
          // est à zero
          
////////////////////////////////////////////////////////////////////////////////
// Le début de l'addresse mémoire commence à 0xF00000: Il est à noté qu'il    // 
// faut spécifier au compilateur quel est le type de variable, par défault il //
// stock en mémoire un integer d'une longueur de 16 bits. Donc pas pratique   //  
// si l'on veux lire et stocker un octet à la fois.                           //
////////////////////////////////////////////////////////////////////////////////

#rom int8 0xF00000 = {'1','2','3','4','5','6'} // Code de déverrouillage.
#rom int8 0xF00012 = {'2','3','4','5','6','7'} // Code de déverrouillage.
#rom int8 0xF00024 = {'3','4','5','6','7','8'} // Code de déverrouillage.
#rom int8 0xF00032 = {'4','5','6','7','8','9'} // Code de déverrouillage.

/////////////////////////////Variable Globales//////////////////////////////////

// Définition et initialisation des variables servant au stockage de mot de  
// passe en EEPROM.

#define PASSWORD_LENGTH 6
char password[PASSWORD_LENGTH] = {};

char k; // Variable de mémorisation des touches de clavier retournés par la 
        // fonction kbd_getc();

char displayID[6];
int8 x;

char userList[10] = {};
int8 len;   
 
#define USER0_ADR 0x00
#define USER1_ADR 0x12
#define USER2_ADR 0x24
#define USER3_ADR 0x32

int8 lcd_adr; 
BOOLEAN getID = FALSE;
BOOLEAN get_logs;
BOOLEAN options = FALSE;
BOOLEAN admin = FALSE;
BOOLEAN menu = FALSE;
BOOLEAN motor_control = FALSE;
//#define ENABLE 1
//#define DISABLED 0

//Variables gestion du temps.
    BYTE hr;
    BYTE min;
    BYTE sec;
    BYTE day;
    BYTE mth;
    BYTE yr;
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// L'appui d'une touche provoque un interruption du programme principal.      //
// En mettant au niveau bas les rangées et les colonnes, on identifie quelle  //
// touche est pesée en effectuant un OU logique et la fonction appelée par    //
// l'interruption retourne la valeur de la touche appuyée.                    //
////////////////////////////////////////////////////////////////////////////////

#int_EXT2 // Utilisation de l'interruption EXT2 cablé sur le portB bit 2.
void EXT2_isr(void) 
   {  
    k = kbd_getc();
   }

char read_from_EEPROM(int8 adr);

void read_RTC_from_EXT_EEPROM(int8 EEPROM_adr);
void write_RTC_to_EXT_EEPROM(int8 EEPROM_adr);
void user_validation();
void password_validation(); 
void users_options();
void motor_gestion();
void user_logs();
void kbd_init();
void user_loggin(int8 x);


#define KEYPAD_BS 'b'
#define KEYPAD_ENTER 'e'

//////////////////////////// Programme principal.///////////////////////////////
void main() 
   {
    enable_interrupts(int_EXT2); // Initialisation des interruptions.
    enable_interrupts(GLOBAL);
    ext_int_edge(2,H_TO_L);// Front descendant sur RB2 Interrupt ext 2
    
    lcd_backlightOn();
    lcd_clear(); //Initialisation de l'affichage.
    init_ext_eeprom(); //Initialisation de l'EEPROM externe.
    init_I2C_Clock(); // Initialisation du RTC.
                      // Set time and date:
                      // hh,mm,ss,DD,MM,YY,WD
    set_I2C_Clock(0x23,0x59,0x50,0x20,0x03,0x12,0x03);
    get_logs = TRUE;
    
    
    if(get_logs == TRUE)
      {
       user_validation(); 
      }
    if(getID == TRUE)
      {
       password_validation();
       if(getID == TRUE && options == TRUE)
         {
         
          
          users_options();
           
         }
       
         
      }
      /*
      else if(admin == TRUE && menu == TRUE)
         {
          user_logs(); 
          
         }
       else
         {
          motor_gestion();
         }
       
     */  
       
   }
///////////////////////Fin du programme principal.//////////////////////////////

// Cette fonction lit et retourne le code qui est en EEPROM.
char read_from_EEPROM(int8 adr)
   { 
    int8 i;
    
    for(i = 0;i < PASSWORD_LENGTH;i++) 
       {
        password[i] = read_eeprom(i + adr);
       }  
return password[i];  
   }
   
void write_RTC_to_EXT_EEPROM(int8 EEPROM_adr)
   {       
    get_I2C_Clock();// Reads date and time
    write_ext_eeprom(EEPROM_adr++,rtc_value.hour);
    write_ext_eeprom(EEPROM_adr++,rtc_value.minute);
    write_ext_eeprom(EEPROM_adr++,rtc_value.second);
    write_ext_eeprom(EEPROM_adr++,rtc_value.day);
    write_ext_eeprom(EEPROM_adr++,rtc_value.month);
    write_ext_eeprom(EEPROM_adr++,rtc_value.year);
   }

// Cette fonction lit et retourne le code qui est en EEPROM.
void read_RTC_from_EXT_EEPROM(int8 EEPROM_adr)
   {
    hr = read_ext_eeprom(EEPROM_adr++);
    min = read_ext_eeprom(EEPROM_adr++);
    sec = read_ext_eeprom(EEPROM_adr++);
    day = read_ext_eeprom(EEPROM_adr++);
    mth = read_ext_eeprom(EEPROM_adr++);
    yr = read_ext_eeprom(EEPROM_adr++); 
   }
   
void user_validation()
   {
    lcd_clear();
    printf("Please enter your ID");
    printf("1- Admin   2- User1\n\r");
    printf("3- User2   4- User3\n\r");
    delay_ms(250);
    getID = FALSE;
    
    do
     {
      kbd_init();
      if(k != '\0') // Si une touche est appuyée, donc si interruption
        {
         switch(k) // Switch/case servant à pointer vers la bonne address EEPROM
            {
             case '1':
                admin = TRUE;
                strcpy(displayID,"Admin");
                read_from_EEPROM(USER0_ADR);
                x = USER0_ADR;
                getID = TRUE;
             break;
             
             case '2':
                admin = FALSE;
                strcpy(displayID,"User1");
                read_from_EEPROM(USER1_ADR);
                x = USER1_ADR;
                getID = TRUE;
             break;
             
             case '3':
                admin = FALSE;
                strcpy(displayID,"User2");
                read_from_EEPROM(USER2_ADR);
                x = USER2_ADR;
                getID = TRUE;
             break;
             
             case '4':
                admin = FALSE;
                strcpy(displayID,"User3");
                read_from_EEPROM(USER3_ADR);
                x = USER3_ADR;
                getID = TRUE;
             break;
            }
        } 
       // On s'assure de remettre une valeur NULL à la variable de lecture.
       k = '\0';
     }
      while(getID == FALSE);
   }

void password_validation()
   {
    int1 passwordValid = FALSE;
    int8 inputCount = 0;
    char userInput[PASSWORD_LENGTH] = {};
    int8 j = 0;
    
    options = FALSE;
    lcd_clear();
    lcd_position(1,5);
    printf("Thank You");
    delay_ms(1000);
    lcd_clear();
    lcd_position(1,2);
    printf("Enter your code");
    lcd_adr = 0xc7;
    do
      {
       kbd_init();
       
       if(k != '\0') // Si une touche est appuyée, donc si interruption
         {
          if(k == KEYPAD_BS) // Est-ce que la touche retour-arrière été appuyée? 
            {  
             inputCount--;
             printf("%c%c",0xfe,--lcd_adr);
             printf(" ");
             delay_ms(300); // Délai servant de fonction anti-rebond(DEBOUNCE)
            }
          else if((k == KEYPAD_ENTER) || (inputCount >= PASSWORD_LENGTH)) 
            {
             if(inputCount == PASSWORD_LENGTH)
               {
                passwordValid = TRUE;      
                for(j = 0;j < PASSWORD_LENGTH;j++)
                   {
                    // On compare le code entré par l'utilisateur avec le mot de passe
                    // qui à été lut auparavant par la fonction read_from_EEPROM().
                    if(userInput[j] != password[j])
                      {
                       passwordValid = FALSE;     
                       lcd_clear();
                       printf("%c%c",0xfe,0x97);
                       printf("Votre code est");
                       printf("%c%c",0xfe,0xd9);
                       printf("incorrect!");
                       delay_ms(500);
                       lcd_clear();
                       printf("%c%c",0xfe,0xd5);
                       printf("Veuillez reessayer");
                       lcd_clear();
                       printf("%c%c",0xfe,0x81);
                       printf("Entrez votre code");
                       lcd_adr = 0xc7;
                      }
                // On remet la chaine entrée par l'utilisateur a NULL pour 
                // un autre essai.
                userInput[j] = '0';
                   }
                // On remet la variable de touche appuyée par l'utilisateur à 0 une
                // fois que les 4 touches on été validées.
                inputCount = 0;        
                if(passwordValid == TRUE)
                  {
                   lcd_clear();
                   lcd_position(1,3);
                   printf("Welcome %s",displayID);
                   delay_ms(1000);
                   if(admin == TRUE)
                     {
                      write_RTC_to_EXT_EEPROM(USER0_ADR);
                      user_loggin(x);
                      strcpy(displayID,"Admin");
                     }  
                   else
                     {
                      switch(x)
                      {
                       case USER1_ADR:
                       write_RTC_to_EXT_EEPROM(USER1_ADR);
                       user_loggin(x);
                       strcpy(displayID,"User1");
                       break;
                      
                       case USER2_ADR:
                       write_RTC_to_EXT_EEPROM(USER2_ADR);
                       user_loggin(x);
                       strcpy(displayID,"User2");
                       break;
                      
                       case USER3_ADR:
                       write_RTC_to_EXT_EEPROM(USER3_ADR);
                       user_loggin(x);
                       strcpy(displayID,"User3");
                       break;
                      }
                     }
                   options = TRUE;  
                  }
               } 
            }
          else
            {
             userInput[inputCount++] = k;
             printf("%c%c",0xfe,lcd_adr);
             printf("%c",k);
             delay_ms(155); // Delai servant de fonction anti-rebond(DEBOUNCE)
             printf("%c%c",0xfe,lcd_adr++);
             printf("*"); // Cache le caractère entré par l'utilisateur.
             delay_ms(150);
            }
            
         }
          // On s'assure de remettre une valeur NULL à la variable de lecture.
          k = '\0'; 
      }
    while(options == FALSE);
   }

   
void users_options()
    { 
     lcd_clear();
     
     printf("  Choose an option  ");
     printf("%c%c",0xfe,0x94);
     printf("1- Motor    2- Tachy");
          
     if(admin == TRUE)
       {
        printf("%c%c",0xfe,0xd4);
        printf("3- Gestion  4- Logs ");
       }
     menu = FALSE;
     //delay_ms(1000);
    do
     {
      kbd_init();
      if(k != '\0') // Si une touche est appuyée, donc si interruption
        {
         switch(k) // Switch/case servant à pointer vers la bonne address EEPROM
            {
             case '1':
               lcd_clear();
               printf("  ok1  ");
               motor_control = FALSE; 
               menu = TRUE;
               motor_gestion();
               delay_ms(250);
               
             break;
             
             case '2':
               lcd_clear();
               printf("  ok2  ");
               menu = TRUE;
               delay_ms(250);
               
             break;
             
             case '3':
               if(admin == FALSE)break;
               lcd_clear();
               printf("  mdp gestion ");
               menu = TRUE;
               
             break;
             
             case '4':
               if(admin == FALSE)break;
               
               menu = TRUE; 
               get_logs = FALSE;
               user_logs();
           //  break; 
            }
        } 
       // On s'assure de remettre une valeur NULL à la variable de lecture.
       k = '\0';
     }
      while(menu == FALSE);
    }   


void user_logs()
   { 
    int8 array_pos = 0;
    
    lcd_clear();
    printf("  Last user logged ");
    lcd_position(2,0);
    printf("     to system     ");
    lcd_position(4,0);
    printf("1- Next   REV- End ");
    get_logs = FALSE;
    do
     {
      kbd_init();
      
      if(k != '\0') // Si une touche est appuyée, donc si interruption
        {
         switch(k) // Switch/case servant à pointer vers la bonne address EEPROM
            {
             case '1':
                
                read_RTC_from_EXT_EEPROM(userList[array_pos++]);
                printf("\f");
                lcd_position(1,0);
                printf("%s",displayID);
                lcd_position(1,5);
                printf(" Time: %x:%x:%x\n\r",hr,min,sec);
                lcd_position(2,5);
                printf(" Date: %x/%x/%x\n\r",day,mth,yr);
                lcd_position(3,0);
                printf("1- Next     2- Last ");
                lcd_position(4,0);
                printf("      REV- End      ");
                get_logs = FALSE;
             break;   
             
             
             case '2':
                
                read_RTC_from_EXT_EEPROM(userList[array_pos--]);
                printf("\f");
                lcd_position(1,0);
                printf("%s",displayID);
                lcd_position(1,5);
                printf(" Time: %x:%x:%x\n\r",hr,min,sec);
                lcd_position(2,5);
                printf(" Date: %x/%x/%x\n\r",day,mth,yr);
                lcd_position(3,0);
                printf("1- Next     2- Last ");
                lcd_position(4,0);
                printf("      REV- End      ");
                get_logs = FALSE;
             break;   
             
             
             case 'r':
                printf("\f");
                lcd_position(1,0);
                printf("      Goodbye       ");
                lcd_position(3,0);
                printf("   Press a key to   ");
                lcd_position(4,0);
                printf("      continue      ");
                //delay_ms(250);
                
                get_logs = FALSE;
                
                //user_validation();
             break;  
             
             
             
            }
        }
       // On s'assure de remettre une valeur NULL à la variable de lecture.
       k = '\0';
       
       delay_ms(250);
      
     }
      while(get_logs == FALSE);
   }

void motor_gestion()
   { 
    lcd_clear();
    printf("  Motor Speed ");
    lcd_position(3,0);
    printf(" 1- Up      2- Down ");
    lcd_position(4,0);
    printf("     REV- End       ");
    motor_control = FALSE;
     
    do
     {
      kbd_init();
      if(k != '\0') // Si une touche est appuyée, donc si interruption
        {
         switch(k) // Switch/case servant à pointer vers la bonne address EEPROM
            {
             case '1':
                printf("\f");
                lcd_position(3,0);
                printf("  ok1  ");
                lcd_position(4,0);
                printf("     REV- End       ");
                motor_control = FALSE;
             break;
             
             case '2':
                printf("\f");
                lcd_position(3,0);
                printf("  ok2  ");
                lcd_position(4,0);
                printf("     REV- End       ");
                motor_control = FALSE;
             break;
             
             case 'r':
                printf("\f");
                lcd_position(3,0);
                printf("  Goodbye  ");
                delay_ms(250);
                motor_control = TRUE;
             //break;  
            }
        } 
       // On s'assure de remettre une valeur NULL à la variable de lecture.
       k = '\0';
       delay_ms(250);
     }
      while(motor_control == FALSE);
   }


void kbd_init()
   {
    // Initialisation du port pour la lecture du clavier
    set_tris_d(0x0f); // Bit0 à bit3 en entrée et bit 4 à bit7 en sortie
    // output_d(0xf0);
    output_low(pin_D4);
    output_low(pin_D5);
    output_low(pin_D6);
    output_low(pin_D7);
   }


void user_loggin(int8 x)
   {
    if(len >= 10)
      {
       len = 0;
      }
    userList[len++] = x;
   }







